// TODO: Insert description here. (generated by yilunchong)

#ifndef PROTOBUF_BENCHMARKS_UTIL_GOGOPROTO_GENERATOR_H_
#define PROTOBUF_BENCHMARKS_UTIL_GOGOPROTO_GENERATOR_H_

#include "google/protobuf/compiler/code_generator.h"
#include "google/protobuf/io/zero_copy_stream.h"
#include "google/protobuf/io/printer.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/descriptor.pb.h"
#include "schema_proto2_to_proto3_util.h"

#include <fstream>

using google::protobuf::FileDescriptorProto;
using google::protobuf::FileDescriptor;
using google::protobuf::DescriptorPool;
using google::protobuf::io::Printer;
using google::protobuf::util::SchemaGroupStripper;
using google::protobuf::util::SchemaAddZeroEnumValue;

namespace google {
namespace protobuf {
namespace compiler {

namespace {

string StripProto(string filename) {
  if (filename.substr(filename.size() - 11) == ".protodevel") {
    // .protodevel
    return filename.substr(0, filename.size() - 11);
  } else {
    // .proto
    return filename.substr(0, filename.size() - 6);
  }
}

DescriptorPool new_pool_;

}  // namespace

class GoGoProtoGenerator : public CodeGenerator {
 public:
  virtual bool GenerateAll(const std::vector<const FileDescriptor*>& files,
                           const string& parameter,
                           GeneratorContext* context,
                           string* error) const {
    for (auto file : files) {
      Generate(file, parameter, context, error);
    }

    return true;
  }
  virtual bool Generate(const FileDescriptor* file,
                        const string& parameter,
                        GeneratorContext* context,
                        string* error) const {
    if (new_pool_.FindFileByName(file->name())) {
      return true;
    }
    for (int i = 0; i < file->dependency_count(); i++) {
      Generate(file->dependency(i), parameter, context, error);
    }
    for (int i = 0; i < file->public_dependency_count(); i++) {
      Generate(file->public_dependency(i), parameter, context, error);
    }
    for (int i = 0; i < file->weak_dependency_count(); i++) {
      Generate(file->weak_dependency(i), parameter, context, error);
    }

    FileDescriptorProto new_file;
    file->CopyTo(&new_file);
    SchemaGroupStripper::StripFile(file, new_file);

    SchemaAddZeroEnumValue enum_scrubber;
    enum_scrubber.ScrubFile(new_file);

    string filename = file->name();
    string basename = StripProto(filename);

    std::vector< std::pair< string, string > > option_pairs;
    ParseGeneratorParameter(parameter, &option_pairs);

    std::unique_ptr<google::protobuf::io::ZeroCopyOutputStream> output(
        context->Open(basename + ".proto"));
    string content = new_pool_.BuildFile(new_file)->DebugString();
    Printer printer(output.get(), '$');
    printer.WriteRaw(content.c_str(), content.size());

    return true;
  }
};

}  // namespace compiler
}  // namespace protobuf
}  // namespace google

#endif  // PROTOBUF_BENCHMARKS_UTIL_GOGOPROTO_GENERATOR_H_
