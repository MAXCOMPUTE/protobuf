# Protocol Buffers - Google's data interchange format
# Copyright 2024 Google Inc.  All rights reserved.
#
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file or at
# https://developers.google.com/open-source/licenses/bsd

# Source:
# - protobuf_c: ext/google/protobuf_c/repeated_field.c
# - protobuf_ffi: lib/google/protobuf/ffi/repeated_field.rb
# - protobuf_java: src/main/java/com/google/protobuf/jruby/RubyRepeatedField.java

module Google
  module Protobuf
    #
    # This class makes RepeatedField act (almost-) like a Ruby Array.
    # It has convenience methods that extend the core C or Java based
    # methods.
    #
    # This is a best-effort to mirror Array behavior.  Two comments:
    #  1) patches always welcome :)
    #  2) if performance is an issue, feel free to rewrite the method
    #     in C.  The source code has plenty of examples
    #
    # KNOWN ISSUES
    #   - #[]= doesn't allow less used approaches such as `arr[1, 2] = 'fizz'`
    #   - #concat should return the orig array
    #   - #push should accept multiple arguments and push them all at the same time
    #
    class RepeatedField[Elem, ElemWrite]
      include Enumerable[Elem]

      type simple_type = :int32 | :int64 | :uint32 | :uint64 | :float | :double | :bool | :string | :bytes

      ##
      # call-seq:
      #     RepeatedField.new(type, type_class = nil, initial_values = [])
      #
      # Creates a new repeated field. The provided type must be a Ruby symbol, and
      # an take on the same values as those accepted by FieldDescriptor#type=. If
      # the type is :message or :enum, type_class must be non-nil, and must be the
      # Ruby class or module returned by Descriptor#msgclass or
      # EnumDescriptor#enummodule, respectively. An initial list of elements may also
      # be provided.
      def self.new: [Elem, ElemWrite] (simple_type type, ?Array[Elem | ElemWrite]? initial_values) -> RepeatedField[Elem, ElemWrite]
        | [Elem, ElemWrite] (:enum type, _EnumModule type_class, ?Array[Elem | ElemWrite]? initial_values) -> RepeatedField[Elem, ElemWrite]
        | [Elem, ElemWrite] (:message type, singleton(AbstractMessage) type_class, ?Array[Elem | ElemWrite]? initial_values) -> RepeatedField[Elem, ElemWrite]
      # def initialize: (simple_type type, ?Array[Elem | ElemWrite]? initial_values) -> void
      #               | (:enum type, _EnumModule type_class, ?Array[Elem | ElemWrite]? initial_values) -> void
      #               | (:message type, singleton(AbstractMessage) type_class, ?Array[Elem | ElemWrite]? initial_values) -> void

      ##
      # call-seq:
      #     RepeatedField.each(&block)
      #
      # Invokes the block once for each element of the repeated field. RepeatedField
      # also includes Enumerable; combined with this method, the repeated field thus
      # acts like an ordinary Ruby sequence.
      def each: () { (Elem) -> void } -> self

      def []: %a{implicitly-returns-nil} (Integer index) -> Elem
            | (Range[Integer] range) -> Array[Elem]?
            | (Integer start, Integer len) -> Array[Elem]?
      alias at []

      def []=: (Integer index, Elem | ElemWrite value) -> void

      def push: (*Elem | ElemWrite elements) -> self

      def <<: (Elem | ElemWrite element) -> self

      def replace: (Array[Elem | ElemWrite] replacements) -> self

      def clear: () -> self

      def length: () -> Integer
      alias size length

      def freeze: () -> self

      def dup: () -> self
      alias clone dup

      def ==: (untyped other) -> bool

      ##
      # call-seq:
      #    RepeatedField.to_ary => array
      #
      # Used when converted implicitly into array, e.g. compared to an Array.
      # Also called as a fallback of Object#to_a
      def to_ary: () -> Array[Elem]

      def hash: () -> Integer

      def +: (RepeatedField[Elem, ElemWrite] | Array[Elem | ElemWrite] other) -> RepeatedField[Elem, ElemWrite]

      def concat: (RepeatedField[Elem, ElemWrite] | Array[Elem | ElemWrite] other) -> self

      private

      def pop_one: () -> Elem?
    end
  end
end

# Source: lib/google/protobuf/repeated_field.rb

#
# This class makes RepeatedField act (almost-) like a Ruby Array.
# It has convenience methods that extend the core C or Java based
# methods.
#
# This is a best-effort to mirror Array behavior.  Two comments:
#  1) patches always welcome :)
#  2) if performance is an issue, feel free to rewrite the method
#     in jruby and C.  The source code has plenty of examples
#
# KNOWN ISSUES
#   - #[]= doesn't allow less used approaches such as `arr[1, 2] = 'fizz'`
#   - #concat should return the orig array
#   - #push should accept multiple arguments and push them all at the same time
#
module Google
  module Protobuf
    class RepeatedField[Elem, ElemWrite]
      extend Forwardable

      # Methods deleted using Forwardable

      def &: [Other] (Array[Other] | _ToAry[Other] other) -> Array[Elem & Other]
      def *: (string times) -> String
           | (int times) -> Array[Elem]
      def -: (Array[top] | _ToAry[top]) -> Array[Elem]
      def <=>: (untyped other) -> Integer?
      def assoc: (top key) -> (Elem & Array[untyped])?
      def bsearch: () { (Elem element) -> (Integer | boolish) } -> Elem?
                 | () -> Enumerator[Elem, Elem?]
      def bsearch_index: () { (Elem element) -> (Integer | boolish) } -> Integer?
                        | () -> Enumerator[Integer, Integer?]
      def combination: (int num) { (Array[Elem] combination) -> void } -> Array[Elem]
                     | (int num) -> Enumerator[Array[Elem], Array[Elem]]
      def compact: () -> Array[Elem]
      def count: () -> Integer
                | (top obj) -> Integer
                | () { (Elem element) -> boolish } -> Integer
      def cycle: (?int? n) { (Elem element) -> void } -> nil
               | (?int? n) -> Enumerator[Elem, nil]
      def difference: (*Array[top] | _ToAry[top] difference) -> Array[Elem]
      def dig: (int index, *untyped identifiers) -> untyped
      def drop: (int n) -> Array[Elem]
      def drop_while: () { (Elem element) -> boolish } -> Array[Elem]
      def eql?: (untyped other) -> bool
      def fetch: [Other] (int index, ?Other default) -> (Elem | Other)
               | [Other] (int index) { (int index) -> Other } -> (Elem | Other)
      def find_index: (top object) -> Integer?
                     | () { (Elem element) -> boolish } -> Integer?
                     | () -> Enumerator[Elem, Integer?]
      alias index find_index
      def flatten: (?int? level) -> Array[untyped]
      def include?: (top obj) -> bool
      def inspect: () -> String
      alias to_s inspect
      def intersection: [Other] (*Array[Other] | _ToAry[Other] other_arrays) -> Array[Elem & Other]
      def join: (?string? separator) -> String
      def permutation: (?int? n) { (Array[Elem] permutation) -> void } -> Array[Elem]
                      | (?int? n) -> Enumerator[Array[Elem], Array[Elem]]
      def product: [Elem2] (Array[Elem2] | _ToAry[Elem2] array2) { ([Elem, Elem2] combination) -> void } -> Array[Elem]
                 | [Elem2] (Array[Elem2] | _ToAry[Elem2] array2) -> Array[[Elem, Elem2]]
                 | [Elem2, Elem3] (Array[Elem2] | _ToAry[Elem2] array2, Array[Elem3] | _ToAry[Elem3] array3) { ([Elem, Elem2, Elem3] combination) -> void } -> Array[Elem]
                 | [Elem2, Elem3] (Array[Elem2] | _ToAry[Elem2] array2, Array[Elem3] | _ToAry[Elem3] array3) -> Array[[Elem, Elem2, Elem3]]
                 | (*Array[untyped] other_arrays) { (Array[untyped] combination) -> void } -> Array[Elem]
                 | (*Array[untyped] other_arrays) -> Enumerator[Array[untyped], Array[Elem]]
      def rassoc: (top obj) -> (Elem & Array[untyped])?
      def repeated_combination: (int n) { (Array[Elem] combination) -> void } -> Array[Elem]
                              | (int n) -> Enumerator[Array[Elem], Array[Elem]]
      def repeated_permutation: (int n) { (Array[Elem] permutation) -> void } -> Array[Elem]
                              | (int n) -> Enumerator[Array[Elem], Array[Elem]]
      def reverse: () -> Array[Elem]
      def rindex: (top object) -> Integer?
                | () { (Elem element) -> boolish } -> Integer?
                | () -> Enumerator[Elem, Integer?]
      def rotate: (?int count) -> Array[Elem]
      def sample: (?random: _Rand) -> Elem?
                | (?int n, ?random: _Rand) -> Array[Elem]
      def shuffle: (?random: _Rand) -> Array[Elem]
      def transpose: () -> Array[untyped]
      def union: [Other] (*Array[Other] | _ToAry[Other] other_arrays) -> Array[Elem | Other]
      def uniq: () ?{ (Elem element) -> top } -> Array[Elem]
      def |: [Other] (Array[Other] | _ToAry[Other] other_array) -> Array[Elem | Other]

      # From pack.rb
      def pack: (string fmt, ?buffer: String?) -> String
      # From pp.rb
      def pretty_print: (PP q) -> untyped
      def pretty_print_cycle: (PP q) -> untyped
      # From shellwords.rb
      def shelljoin: () -> String

      # Methods directly defined to imitate Array

      def first: (?nil n) -> Elem?
               | (Integer n) -> Array[Elem]
      def last: (?nil n) -> Elem?
              | (Integer n) -> Array[Elem]
      def pop: (?nil n) -> Elem?
             | (Integer n) -> Array[Elem?]
      def empty?: () -> bool

      # array aliases into enumerable
      alias slice []
      alias values_at select
      alias map collect

      # Delegation utilities specialized for Array destructive methods
      private def self.define_array_wrapper_method: (interned method_name) -> void
      private def self.define_array_wrapper_with_result_method: (interned method_name) -> void

      # Methods deleted using define_array_wrapper_method

      def delete: (top item) -> Elem?
                # Originally: [Result] (top item) { (Elem nosuch) -> Result } -> (Elem | Result)
                | [Result] (top item) { () -> Result } -> (Elem | Result)
      def delete_at: (int index) -> Elem?
                   # It doesn't exist in the original Array
                   | [Result] (int index) { () -> Result } -> (Elem | Result)
      def shift: () -> Elem?
               | (int n) -> Array[Elem]
               # It doesn't exist in the original Array
               | [Result] () { () -> Result } -> (Elem | Result)
               # It doesn't exist in the original Array
               | (int n) { () -> void } -> Array[Elem]
      def slice!: (int n) -> Elem?
                 | (int start, int length) -> Array[Elem]?
                 | (Range[Integer] range) -> Array[Elem]?
                 # It doesn't exist in the original Array
                 | [Result] (int index) { () -> Result } -> (Elem | Result)
                 # It doesn't exist in the original Array
                 | [Result] (int start, int len) { () -> Result } -> (Array[Elem] | Result)
                 # It doesn't exist in the original Array
                 | [Result] (Range[Integer] range) { () -> Result } -> (Array[Elem] | Result)
      def unshift: (*Elem | ElemWrite elements) -> Array[Elem]
                 # It doesn't exist in the original Array
                 | (*Elem | ElemWrite elements) { () -> void } -> Array[Elem]

      # Methods deleted using define_array_wrapper_with_result_method

      def collect!: () { (Elem element) -> (Elem | ElemWrite) } -> Array[Elem | ElemWrite]
                  | () -> Enumerator[Elem, Array[Elem | ElemWrite]]
      def compact!: () -> Array[Elem]?
      def delete_if: () { (Elem element) -> boolish } -> Array[Elem]
                   | () -> Enumerator[Elem, Array[Elem]]
      def each_index: () { (Integer index) -> void } -> Array[Elem]
                    | () -> Enumerator[Integer, Array[Elem]]
      def fill: (Elem | ElemWrite obj, ?int? start, ?int? length) -> Array[Elem | ElemWrite]
              | (Elem | ElemWrite obj, Range[Integer] range) -> Array[Elem | ElemWrite]
              | (?int? start, ?int? length) { (Integer index) -> (Elem | ElemWrite) } -> Array[Elem | ElemWrite]
              | (Range[Integer] range) { (Integer index) -> (Elem | ElemWrite) } -> Array[Elem | ElemWrite]
      def flatten!: (?int? level) -> Array[untyped]?
      def insert: (int index, *Elem | ElemWrite objects) -> Array[Elem | ElemWrite]
      def reverse!: () -> Array[Elem]
      def rotate!: (?int count) -> Array[Elem]
      def select!: () { (Elem element) -> boolish } -> Array[Elem]?
                 | () -> Enumerator[Elem, Array[Elem]?]
      def shuffle!: (?random: _Rand) -> Array[Elem]
      def sort!: () -> Array[Elem]
               | () { (Elem a, Elem b) -> int } -> Array[Elem]
      def sort_by!: () { (Elem element) -> int } -> Array[Elem]
                  | () -> Enumerator[Elem, Array[Elem]]
      def uniq!: () ?{ (Elem element) -> top } -> Array[Elem]

      alias keep_if select!
      alias map! collect!
      alias reject! delete_if


      # propagates changes made by user of enumerator back to the original repeated field.
      # This only applies in cases where the calling function which created the enumerator,
      # such as #sort!, modifies itself rather than a new array, such as #sort
      class ProxyingEnumerator[Elem, ElemWrite] < ::Struct[untyped]
        def self.new: [Elem, ElemWrite] (RepeatedField[Elem, ElemWrite] repeated_field, Enumerator[Elem, void] external_enumerator) -> ProxyingEnumerator[Elem, ElemWrite]
                    | [Elem, ElemWrite] (repeted_field: RepeatedField[Elem, ElemWrite] repeated_field, external_enumerator: Enumerator[Elem, void]) -> ProxyingEnumerator[Elem, ElemWrite]
        def initialize: (RepeatedField[Elem, ElemWrite] repeated_field, Enumerator[Elem, void] external_enumerator) -> void
                      | (repeted_field: RepeatedField[Elem, ElemWrite] repeated_field, external_enumerator: Enumerator[Elem, void]) -> void
        attr_accessor repeated_field: RepeatedField[Elem, ElemWrite]
        attr_accessor external_enumerator: Enumerator[Elem, void]

        def each: (*untyped args) { (Elem element) -> untyped } -> Array[untyped]
      end
    end
  end
end
